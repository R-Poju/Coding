不同服务端如何建立通信



一、通信的核心模型：客户端-服务端（Client-Server）

所有网络服务通信的本质都是“请求-响应”模型：

服务端：被动提供服务（如登录验证、数据查询），监听特定端口，等待客户端请求

客户端：主动发起请求（如调用登录接口），发送数据，接收服务端响应



二、grpc通信的核心组件

grpc是基于http/2的高性能RPC框架，用Protobuf定义服务和消息

1.Protobuf定义：服务的“合同”。首先需要通过.proto文件定义服务接口和消息格式，客户端和服务端双方都按这个格式序列化和反序列化数据

2.Stub（存根）：客户端的“代理“。服务端实现 .proto 中定义的服务后，protobuf编译器会生成客户端Stub（存根）代码，Stub作用是：

​	将客户端的请求（如LoginReq）序列化为二进制数据（Protobuf格式）；

​	通过网络（HTTP/2）发送到服务端的地址（如localhost:50051）

​	接收服务端的响应（二进制数据），反序列化为客户端可读的格式（如LoginRsp）

3.上下文（Context）：通信的“控制面板”。ClientContext（客户端上下文）是grpc中传递调用控制信息的载体，核心作用包括：

​	传递元数据

​	控制调用生命周期

​	传递状态信息

​	连接池



三、完整的通信流程

Step1：客户端准备请求

​	创建LoginReq对象，设置uid和token（填充请求数据）

​	创建ClientContext对象（可设置超时、元数据等）

Step2：客户端获取连接（Stub）

​	通过连接池pool_获取一个可用的grpc Stub（底层是TCP连接+HTTP/2会话）

​	Stub知道服务端的地址（如127.0.0.1:50051）和服务方法（LoginService::Login）

Step3：发起RPC调用

调用stub->Login(&context, request, &reply):

​	Stub将request（LoginReq）序列化为Protobuf二进制数据

​	通过HTTP/2发送请求到服务端，携带context中的元数据

​	等待服务端响应，将二进制响应反序列化为reply（LoginReq）

Step4：服务端处理请求

服务端监听端口（如50051），收到请求后：

​	解析HTTP/2请求，提取Protobuf数据，反序列化为LoginReq

​	读取ServerContext中的元数据（如认证token）

​	调用服务端实现的LoginService::Login方法（业务逻辑，验证token是否有效）

​	将处理结果（LoginRsq）序列化为二进制数据，通过HTTP/2返回给客户端

Step5：客户端处理结果

​	客户端收到响应后，status.ok()判断调用是否成功（网络正常+服务端处理成功）

​	成功则返回reply（含登录结果），失败则设置错误码（如ErrorCodes：：RPCFailed）

​	通过Defer确保Stub归还连接池（复用连接）



四、为什么需要“上下文”

上下文是贯穿整个调用链的“信息载体”，解决了三个核心问题：

1.解耦控制信息与业务数据

* 业务数据（如id、token）通过Protobuf消息传递，控制信息（如超时、认证）通过上下文传递，避免污染业务接口

2.支持调用链路的动态调整

* 网关服务可以在上下文中添加限流标记，后续服务根据该标记决定是否拒绝请求，或通过链路追踪id，串联多个服务的日志

3.确保资源安全释放

* 上下文与服务端的生命周期绑定，当取消调用或超时，上下文会触发资源清理（如关闭文件句柄、释放锁）



总结：不同服务端的通信本质是基于协议的请求-响应，grpc通过以下机制简化这一过程：

* Protobuf：定义统一的消息格式
* Stub：客户端代理，隐藏网络细节
* 上下文：传递控制信息（元数据、超时、取消）
* 连接池：复用网络资源，提升性能











































